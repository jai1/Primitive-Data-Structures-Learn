package org.learn.interview;

public class BinaryTree <T extends Comparable>{
	/*
	 * Property:-
	 * a. Every node on the right subtree has to be larger than the current node 
	 *    and every node on the left subtree has to be smaller than 
	 *    (or equal to - should not be the case as only unique values 
	 *    should be in the tree - this also poses the question as to 
	 *    if such nodes should be left or right of this parent) the current node
	 * b. If you look at each the tree from the bottom, it looks like a sorted array
	 * Example:-
	 * 1. Not a BST (Because of 13)
	 *	 	 10               
	 *       / \       
	 *      /   \      
	 *     /     \     
	 *    /       \    
	 *    9       15       
	 *   / \      / \   
	 *  /   \    /   \  
	 *  2   10  13   16   
	 * / \     / \  / \ 
	 * 1 13   12 14  15 18
	 * 
	 * 2. A BST         
	 *	 	 10               
	 *       / \       
	 *      /   \      
	 *     /     \     
	 *    /       \    
	 *    9       15       
	 *   / \      / \   
	 *  /   \    /   \  
	 *  2   10  13   17   
	 * / \     / \   / \ 
	 * 1  8   12 14  16 18 
	 */	 
	 
	/*
	 * Comapany:- Microsoft
	 * Question:- WAP to validate a binary tree.
	 * Soln 1:- For each node check if element left < element < element right
	 * 			Can't use this since it will give Example 1 as a valid BST
	 * Soln 2:- recursively check that the left smaller than the right  
	 * 
	 */
	private T leftValue = null;
	public boolean validateBST(BTNode<T> root) {
		if(root == null) 
			return true;

		if(!validateBST(root.left))
			return false;
		
		// root < leftValue
		if(leftValue != null && root.data.compareTo(leftValue) < 0)
			return false;
		
		leftValue = root.data;
		
		return validateBST(root.right);
	}
	/*
	bool isBST(struct node* root)
	{
	    static struct node *prev = NULL;
	     
	    // traverse the tree in inorder fashion and keep track of prev node
	    if (root)
	    {
	        if (!isBST(root->left))
	          return false;
	 
	        // Allows only distinct valued nodes 
	        if (prev != NULL && root->data <= prev->data)
	          return false;
	 
	        prev = root;
	 
	        return isBST(root->right);
	    }
	 
	    return true;
	}
	*/	
}
